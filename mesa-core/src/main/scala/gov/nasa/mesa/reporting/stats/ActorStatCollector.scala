/**
  * Copyright Â© 2020 United States Government as represented by the
  * Administrator of the National Aeronautics and Space Administration.  All
  * Rights Reserved.
  *
  * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
  * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING,
  * BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM
  * TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
  * A PARTICULAR PURPOSE, OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT THE
  * SUBJECT SOFTWARE WILL BE ERROR FREE, OR ANY WARRANTY THAT DOCUMENTATION,
  * IF PROVIDED, WILL CONFORM TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES
  * NOT, IN ANY MANNER, CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY
  * PRIOR RECIPIENT OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE
  * PRODUCTS OR ANY OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT
  * SOFTWARE.  FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND
  * LIABILITIES REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL
  * SOFTWARE, AND DISTRIBUTES IT "AS IS."
  *
  * Waiver and Indemnity:  RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
  * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS,
  * AS WELL AS ANY PRIOR RECIPIENT.  IF RECIPIENT'S USE OF THE SUBJECT
  * SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES OR LOSSES
  * ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS BASED ON, OR
  * RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT SOFTWARE, RECIPIENT SHALL
  * INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS CONTRACTORS
  * AND SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT, TO THE EXTENT
  * PERMITTED BY LAW.  RECIPIENT'S SOLE REMEDY FOR ANY SUCH MATTER SHALL BE
  * THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
  */
package gov.nasa.mesa.reporting.stats

import java.io.{File, PrintWriter}

import akka.actor.ActorRef
import com.typesafe.config.Config
import gov.nasa.mesa.core.MesaActor
import gov.nasa.mesa.reporting.stats.printers.{ActorStatsCSVPrinter,
  ActorStatsTabularPrinter}
import gov.nasa.race.config.ConfigUtils._

/**
  * This represents an actor, referred to as stat-collector, which is used to
  * collect performance parameters for individual actors, and print the
  * collected data in the csv file specified in the given config.
  *
  * This actor subscribed to EventStream, the main event bus of this actor
  * system, and listens to the classes MailboxStats and MsgProcessingStats.
  *
  * MailboxStats is generated by StatsMailboxType and captures information
  * about the actor mailbox queue, such as the queue size, and message wait time
  * in the queue. MsgProcessingStats is generated by the actor and captures
  * the service time used to process the message.
  *
  * To activate 'actor stats features' provided by this actor for an actor X,
  * the two following steps are required.
  *
  * 1) Specifying the stat-collector actor in the configuration file:
  *   {
  *     name = "stat-collector"
  *     class = "gov.nasa.mesa.reporting.stats.ActorStatCollector"
  *     output-path = // path to a csv output file
  *     print-on-console = // if set to true, it prints the results on the
  *                        // console
  *   }
  *
  * 2) Add the following to the actor X configuration (note that X must be a
  * sub-type of MesaActor):
  *
  *   stats = {
  *     mailbox = true // to retrieve stats about the actor X' mailbox
  *     service = true // to retrieve service time for actor X
  *   }
  *
  *   @param config the actor configuration
  */
class ActorStatCollector(val config: Config) extends MesaActor {

  /** A map from actor references to ActorStats objects which store the stats
    * received from the corresponding actors.
    */
  val actorStats = scala.collection.mutable.Map[ActorRef, ActorStats]()

  /** This actor starts listening to MailboxStats and MsgProcessingStats
    * messages on the actor system's bus.
    */
  context.system.eventStream.subscribe(self, classOf[MailboxStats])
  context.system.eventStream.subscribe(self, classOf[MsgProcessingStats])

  val consoleTabularPrinter =
    if (config.getBooleanOrElse("print-on-console", false)) {
      Some(new ActorStatsTabularPrinter(new PrintWriter(System.out, true)))
    } else None

  val outputPath = config.getOptionalString("output-path")
  val csvFilePrinter = if (outputPath.nonEmpty) {
    val file = new File(outputPath.get)
    val dir = file.getParentFile
    if (!dir.isDirectory) dir.mkdirs
    Some(new ActorStatsCSVPrinter(new PrintWriter(file)))
  } else None

  /** Handles MailboxStats and MsgProcessingStats massages by delegating to
    * associated handlers.
    *
    * @return a partial function with the actor logic.
    */
  override def handleMessage: Receive = {
    case msg: MailboxStats => {
      handleMailboxStats(msg)
    }
    case msg: MsgProcessingStats =>
      handleMsgProcessingStats(msg)
  }

  /** Obtains an ActorStats object for a given actor from 'actorStats' which
    * stores actor statistics. If there is not any entries associated to the
    * actor, it creates one.
    *
    * @param ref the actor reference
    * @return an ActorStats object associated to the given actor.
    */
  def getEntry(ref: ActorRef): ActorStats = {
    if (!actorStats.contains(ref))
      actorStats += (ref -> ActorStats(ref, 0, 0, 0, 0, 0, 0, 0, 0))
    actorStats(ref)
  }

  /** Handles messages sent about actor mailboxes.
    *
    * @param msg a message including information about the actor mailbox, such
    *            as its size, and the time used to process a message.
    */
  def handleMailboxStats(msg: MailboxStats) = {
    val stats = getEntry(msg.receiver)
    stats.numMsgQueued = stats.numMsgQueued + 1

    var oldAve, oldVar, value: Double = 0.0
    var n = stats.numMsgQueued

    oldAve = stats.aveQueueWait
    oldVar = stats.varQueueWait
    value = (msg.exitTime - msg.entryTime)
    stats.aveQueueWait = computeAverage(n, oldAve, value)
    stats.varQueueWait = computeVariance(n, oldVar, oldAve, stats.aveQueueWait,
      value)

    oldAve = stats.aveQueueSize
    oldVar = stats.varQueueSize
    stats.aveQueueSize = computeAverage(n, oldAve, msg.queueSize)
    stats.varQueueSize = computeVariance(n, oldVar, oldAve, stats.aveQueueSize,
      msg.queueSize)
  }

  /** Calculates the average incrementally.
    *
    * @param n the total number of values
    * @param oldAve the previous average, average for the first n-1 values
    * @param a_n the new value
    * @return the average of the n values.
    */
  def computeAverage(n: Long, oldAve: Double, a_n: Double): Double = {
    return ((oldAve * (n-1)) + a_n)/n;
  }

  /** Calculates the variance incrementally.
    *
    * @param n the total number of values
    * @param oldVar the previous variance, average for the first n-1 values
    * @param oldAve the previous average, average for the first n-1 values
    * @param ave the average of the n values
    * @param a_n the new value
    * @return the variance of the n values.
    */
  def computeVariance(n: Long, oldVar: Double, oldAve: Double, ave: Double, a_n: Double): Double = {
    return ((((n-1) * oldVar) + ((a_n-oldAve)*(a_n-ave)))/n)
  }

  /** Handles messages sent about the actor service times.
    *
    * @param msg a message including information about the actor service time.
    */
  def handleMsgProcessingStats(msg: MsgProcessingStats) = {
    val stats = getEntry(msg.self)
    stats.numMsgProcessed = stats.numMsgProcessed + 1

    var oldAve = stats.aveServiceTime
    var oldVar = stats.varServiceTime
    var value = (msg.exitTime - msg.entryTime)
    stats.aveServiceTime = computeAverage(stats.numMsgProcessed, stats.aveServiceTime, value)
    stats.varServiceTime = computeVariance(stats.numMsgProcessed, oldVar, oldAve, stats.aveServiceTime, value)
  }

  /** Prints the results on the console and in the csv file.
    */
  def printResults = {
    consolePrint
    csvFilePrint
  }

  /** Prints the results on the console.
    */
  def consolePrint = {
    if (consoleTabularPrinter.isDefined) {
      consoleTabularPrinter.get.printHeader
      consoleTabularPrinter.get.printStats(actorStats)
    }
  }

  /** Prints the results in the csv file.
    */
  def csvFilePrint = {
    if (csvFilePrinter.isDefined) {
      csvFilePrinter.get.printHeader
      csvFilePrinter.get.printStats(actorStats)
      csvFilePrinter.get.close
    }
  }

  /** Called when terminating this actor.
    *
    * @param originator the actor sending the termination request
    * @return true if the termination is successful, otherwise returns false.
    */
  override def onTerminateRaceActor(originator: ActorRef) = {
    printResults
    super.onTerminateRaceActor(originator)
  }
}

/** A container type that stores the latest information received about the
  * given actor.
  *
  * @param actor the actor reference
  * @param aveQueueWait the average wait time for messages in the mailbox
  * @param varQueueWait the variance for messages wait time in the mailbox
  * @param aveQueueSize the average mailbox queue size
  * @param varQueueSize the variance for the mailbox queue size
  * @param numMsgQueued the total number of messages entered the mailbox
  * @param aveServiceTime the average time for processing messages
  * @param varServiceTime variance for the message processing time
  * @param numMsgProcessed the total number of messages processed by the actor
  */
case class ActorStats(var actor: ActorRef,
                      var aveQueueWait: Double,
                      var varQueueWait: Double,
                      var aveQueueSize: Double,
                      var varQueueSize: Double,
                      var numMsgQueued: Long,
                      var aveServiceTime: Double,
                      var varServiceTime: Double,
                      var numMsgProcessed: Long) {

  /** Gets the name of the actor
    *
    * @return the actor name
    */
  def actorName: String = actor.path.name

  override def toString(): String = {
    s"Stats for actor ${actor.toString}" +
      s"\n  ave queue wait: $aveQueueWait" +
      s"\n  ave queue size: $aveQueueSize" +
      s"\n  num of queued msgs: $numMsgQueued" +
      s"\n  ave service time: $aveServiceTime" +
      s"\n  num of processed msgs: $numMsgProcessed"
  }
}